{"ast":null,"code":"import _slicedToArray from\"/Users/apb/Coding/aballo-website/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import{useState,useEffect}from\"react\";export default function useOnScreen(ref){var _useState=useState(false),_useState2=_slicedToArray(_useState,2),isIntersecting=_useState2[0],setIntersecting=_useState2[1];var observer=new IntersectionObserver(function(_ref){var _ref2=_slicedToArray(_ref,1),entry=_ref2[0];return setIntersecting(entry.isIntersecting);});useEffect(function(){observer.observe(ref.current);// Remove the observer as soon as the component is unmounted\nreturn function(){observer.disconnect();};},[]);return isIntersecting;}","map":{"version":3,"names":["useState","useEffect","useOnScreen","ref","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","observe","current","disconnect"],"sources":["/Users/apb/Coding/aballo-website/src/hooks/useOnScreen.js"],"sourcesContent":["import { useState, useEffect } from \"react\";\nexport default function useOnScreen(ref) {\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  const observer = new IntersectionObserver(([entry]) =>\n    setIntersecting(entry.isIntersecting)\n  );\n\n  useEffect(() => {\n    observer.observe(ref.current);\n    // Remove the observer as soon as the component is unmounted\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  return isIntersecting;\n}\n"],"mappings":"sHAAA,OAASA,QAAT,CAAmBC,SAAnB,KAAoC,OAApC,CACA,cAAe,SAASC,CAAAA,WAAT,CAAqBC,GAArB,CAA0B,CACvC,cAA0CH,QAAQ,CAAC,KAAD,CAAlD,wCAAOI,cAAP,eAAuBC,eAAvB,eAEA,GAAMC,CAAAA,QAAQ,CAAG,GAAIC,CAAAA,oBAAJ,CAAyB,gDAAEC,KAAF,gBACxCH,CAAAA,eAAe,CAACG,KAAK,CAACJ,cAAP,CADyB,EAAzB,CAAjB,CAIAH,SAAS,CAAC,UAAM,CACdK,QAAQ,CAACG,OAAT,CAAiBN,GAAG,CAACO,OAArB,EACA;AACA,MAAO,WAAM,CACXJ,QAAQ,CAACK,UAAT,GACD,CAFD,CAGD,CANQ,CAMN,EANM,CAAT,CAQA,MAAOP,CAAAA,cAAP,CACD"},"metadata":{},"sourceType":"module"}